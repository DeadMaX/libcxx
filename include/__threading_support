// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_THREADING_SUPPORT
#define _LIBCPP_THREADING_SUPPORT

#include <__config>
#include <memory> // for hash<>

#ifndef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
#pragma GCC system_header
#endif

#ifndef _LIBCPP_HAS_NO_THREADS

#ifndef __libcpp_has_include
  #ifndef __has_include
    #define __libcpp_has_include(x) 0
  #else
    #define __libcpp_has_include(x) __has_include(x)
  #endif
#endif

#if defined(_LIBCPP_HAS_THREAD_API_EXTERNAL) && \
    !__libcpp_has_include(<__external_threading>)
// If the <__external_threading> header is absent, build libc++ against a
// pthread-oriented thread api but leave out its implementation. This setup
// allows building+testing of an externally-threaded library variant (on any
// platform that supports pthreads). Here, an 'externally-threaded' library
// variant is one where the implementation of the libc++ thread api is provided
// as a separate library.
#define _LIBCPP_HAS_THREAD_API_EXTERNAL_PTHREAD
#endif

#if defined(_LIBCPP_HAS_THREAD_API_EXTERNAL) && \
    __libcpp_has_include(<__external_threading>)
#include <__external_threading>
#else

#if defined(_LIBCPP_HAS_THREAD_API_PTHREAD) || \
    defined(_LIBCPP_HAS_THREAD_API_EXTERNAL_PTHREAD)
#endif

#if defined(_LIBCPP_HAS_THREAD_API_EXTERNAL)
#define _LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_FUNC_VIS
#else
#define _LIBCPP_THREAD_ABI_VISIBILITY inline _LIBCPP_INLINE_VISIBILITY
#endif

_LIBCPP_BEGIN_NAMESPACE_STD

class __libcpp_mutex_t;
class __libcpp_condvar_t;
class __libcpp_exec_once_flag;
class __libcpp_thread_id;
class __libcpp_thread_t;
class __libcpp_tls_key;

template<>
struct hash<__libcpp_thread_id>
{
	_LIBCPP_THREAD_ABI_VISIBILITY
	size_t operator()(const __libcpp_thread_id &c) const;
};

// Mutex
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_recursive_mutex_init(__libcpp_mutex_t &__m);

_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_mutex_lock(__libcpp_mutex_t &__m);

_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_mutex_trylock(__libcpp_mutex_t &__m);

_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_mutex_unlock(__libcpp_mutex_t &__m);

_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_mutex_destroy(__libcpp_mutex_t &__m);

// Condition variable
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_condvar_signal(__libcpp_condvar_t &__cv);

_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_condvar_broadcast(__libcpp_condvar_t &__cv);

_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_condvar_wait(__libcpp_condvar_t &__cv, __libcpp_mutex_t &__m);

_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_condvar_timedwait(__libcpp_condvar_t &__cv, __libcpp_mutex_t &__m,
		chrono::time_point<chrono::system_clock, chrono::nanoseconds> __tp);

_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_condvar_destroy(__libcpp_condvar_t &__cv);

// Execute once
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_execute_once(__libcpp_exec_once_flag &flag,
                          void (*init_routine)(void));

// Thread id
#if defined(__APPLE__) && !defined(__arm__)
_LIBCPP_THREAD_ABI_VISIBILITY
mach_port_t __libcpp_thread_get_port();
#endif

_LIBCPP_THREAD_ABI_VISIBILITY
bool __libcpp_thread_id_equal(__libcpp_thread_id &t1, __libcpp_thread_id &t2);

_LIBCPP_THREAD_ABI_VISIBILITY
bool __libcpp_thread_id_less(__libcpp_thread_id &t1, __libcpp_thread_id &t2);

// Thread
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_thread_create(__libcpp_thread_t &__t, void *(*__func)(void *),
                           void *__arg);

_LIBCPP_THREAD_ABI_VISIBILITY
__libcpp_thread_id __libcpp_thread_get_current_id();

_LIBCPP_THREAD_ABI_VISIBILITY
__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t &__t);

_LIBCPP_THREAD_ABI_VISIBILITY
void __libcpp_thread_reset_id(__libcpp_thread_id &__t);

_LIBCPP_THREAD_ABI_VISIBILITY
bool __libcpp_thread_joinable(const __libcpp_thread_t &__t);

_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_thread_join(__libcpp_thread_t &__t);

_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_thread_detach(__libcpp_thread_t &__t);

_LIBCPP_THREAD_ABI_VISIBILITY
void __libcpp_thread_yield();

// Thread local storage
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_tls_create(__libcpp_tls_key &__key, void (*__at_exit)(void *));

_LIBCPP_THREAD_ABI_VISIBILITY
void *__libcpp_tls_get(const __libcpp_tls_key &__key);

_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_tls_set(__libcpp_tls_key &__key, void *__p);

_LIBCPP_END_NAMESPACE_STD

#if defined(_LIBCPP_HAS_THREAD_API_PTHREAD) || \
    defined(_LIBCPP_BUILDING_THREAD_API_EXTERNAL_PTHREAD)

#include <pthread.h>
#include <sched.h>
#include <functional>

_LIBCPP_BEGIN_NAMESPACE_STD

// Mutex
class __libcpp_mutex_t
{
public:
	pthread_mutex_t _mutex;
#ifndef _LIBCPP_HAS_NO_CONSTEXPR
	constexpr __libcpp_mutex_t() _NOEXCEPT : _mutex(PTHREAD_MUTEX_INITIALIZER) {}
#else
	__libcpp_mutex_t() _NOEXCEPT : _mutex(PTHREAD_MUTEX_INITIALIZER) {}
#endif
};

// Condition Variable
class __libcpp_condvar_t
{
public:
	pthread_cond_t _condvar;
#ifndef _LIBCPP_HAS_NO_CONSTEXPR
	constexpr __libcpp_condvar_t() _NOEXCEPT : _condvar(PTHREAD_COND_INITIALIZER) {}
#else
	__libcpp_condvar_t() _NOEXCEPT : _condvar(PTHREAD_COND_INITIALIZER) {}
#endif
};

// Execute once
class __libcpp_exec_once_flag
{
public:
	pthread_once_t _flag;
	__libcpp_exec_once_flag() _NOEXCEPT : _flag(PTHREAD_ONCE_INIT) {}
};

// Thread id
class __libcpp_thread_id
{
public:
// 	__libcpp_thread_id(pthread_t id) _NOEXCEPT : _id(id) {}
	__libcpp_thread_id() _NOEXCEPT : _id(0) {}
	pthread_t _id;
};

size_t hash<__libcpp_thread_id>::operator()(const __libcpp_thread_id &c) const
{
	return hash<pthread_t>()(c._id);
}

// Thread
class __libcpp_thread_t
{
public:
	typedef pthread_t native_handle_type;

	pthread_t _thread;
	__libcpp_thread_t() _NOEXCEPT : _thread(0) {}
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
	_LIBCPP_INLINE_VISIBILITY
    __libcpp_thread_t(__libcpp_thread_t &&__t) _NOEXCEPT : _thread(__t._thread) {__t._thread = 0;}
	_LIBCPP_INLINE_VISIBILITY
    __libcpp_thread_t& operator=(__libcpp_thread_t&& __t) _NOEXCEPT
	{
		_thread = __t._thread;
		__t._thread = 0;
		return *this;
	}
#endif
};

// Thrad Local Storage
class __libcpp_tls_key
{
public:
	pthread_key_t _key;
};

int __libcpp_recursive_mutex_init(__libcpp_mutex_t &__m)
{
  pthread_mutexattr_t attr;
  int __ec = pthread_mutexattr_init(&attr);
  if (__ec)
    return __ec;
  __ec = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutex_init(&__m._mutex, &attr);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutexattr_destroy(&attr);
  if (__ec) {
    pthread_mutex_destroy(&__m._mutex);
    return __ec;
  }
  return 0;
}

int __libcpp_mutex_lock(__libcpp_mutex_t &__m)
{
  return pthread_mutex_lock(&__m._mutex);
}

int __libcpp_mutex_trylock(__libcpp_mutex_t &__m)
{
  return pthread_mutex_trylock(&__m._mutex);
}

int __libcpp_mutex_unlock(__libcpp_mutex_t &__m)
{
  return pthread_mutex_unlock(&__m._mutex);
}

int __libcpp_mutex_destroy(__libcpp_mutex_t &__m)
{
  return pthread_mutex_destroy(&__m._mutex);
}

// Condition Variable
int __libcpp_condvar_signal(__libcpp_condvar_t &__cv)
{
  return pthread_cond_signal(&__cv._condvar);
}

int __libcpp_condvar_broadcast(__libcpp_condvar_t &__cv)
{
  return pthread_cond_broadcast(&__cv._condvar);
}

int __libcpp_condvar_wait(__libcpp_condvar_t &__cv, __libcpp_mutex_t &__m)
{
  return pthread_cond_wait(&__cv._condvar, &__m._mutex);
}

int __libcpp_condvar_timedwait(__libcpp_condvar_t &__cv, __libcpp_mutex_t &__m,
	chrono::time_point<chrono::system_clock, chrono::nanoseconds> __tp)
{
    chrono::nanoseconds d = __tp.time_since_epoch();
    if (d > chrono::nanoseconds(0x59682F000000E941))
        d = chrono::nanoseconds(0x59682F000000E941);
    timespec __ts;
    chrono::seconds s = chrono::duration_cast<chrono::seconds>(d);
    typedef decltype(__ts.tv_sec) ts_sec;
    _LIBCPP_CONSTEXPR ts_sec ts_sec_max = numeric_limits<ts_sec>::max();
    if (s.count() < ts_sec_max)
    {
        __ts.tv_sec = static_cast<ts_sec>(s.count());
        __ts.tv_nsec = static_cast<decltype(__ts.tv_nsec)>((d - s).count());
    }
    else
    {
        __ts.tv_sec = ts_sec_max;
        __ts.tv_nsec = giga::num - 1;
    }

    return pthread_cond_timedwait(&__cv._condvar, &__m._mutex, &__ts);
}

int __libcpp_condvar_destroy(__libcpp_condvar_t &__cv)
{
  return pthread_cond_destroy(&__cv._condvar);
}

// Execute once
int __libcpp_execute_once(__libcpp_exec_once_flag &flag,
                          void (*init_routine)(void)) {
  return pthread_once(&flag._flag, init_routine);
}

// Thread id
#if defined(__APPLE__) && !defined(__arm__)
mach_port_t __libcpp_thread_get_port() {
    return pthread_mach_thread_np(pthread_self());
}
#endif

// Returns non-zero if the thread ids are equal, otherwise 0
bool __libcpp_thread_id_equal(__libcpp_thread_id &t1, __libcpp_thread_id &t2)
{
  return pthread_equal(t1._id, t2._id) != 0;
}

// Returns non-zero if t1 < t2, otherwise 0
bool __libcpp_thread_id_less(__libcpp_thread_id &t1, __libcpp_thread_id &t2)
{
  return t1._id < t2._id;
}

// Thread
int __libcpp_thread_create(__libcpp_thread_t &__t, void *(*__func)(void *),
                           void *__arg)
{
  return pthread_create(&__t._thread, 0, __func, __arg);
}

__libcpp_thread_id __libcpp_thread_get_current_id()
{
  __libcpp_thread_id id;
  id._id = pthread_self();
  return id;
}

__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t &__t)
{
  __libcpp_thread_id id;
  id._id = __t._thread;
  return id;
}

void __libcpp_thread_reset_id(__libcpp_thread_id &__t)
{
  __t._id = 0;
}

bool __libcpp_thread_joinable(const __libcpp_thread_t &__t)
{
  return __t._thread != 0;
}

int __libcpp_thread_join(__libcpp_thread_t &__t)
{
  int res = pthread_join(__t._thread, 0);
  if (res == 0)
	__t._thread = 0;
  return res;
}

int __libcpp_thread_detach(__libcpp_thread_t &__t)
{
  int res = pthread_detach(__t._thread);
  if (res == 0)
	__t._thread = 0;
  return res;
}

void __libcpp_thread_yield()
{
  sched_yield();
}

// Thread local storage
int __libcpp_tls_create(__libcpp_tls_key &__key, void (*__at_exit)(void *))
{
  return pthread_key_create(&__key._key, __at_exit);
}

void *__libcpp_tls_get(const __libcpp_tls_key &__key)
{
  return pthread_getspecific(__key._key);
}

int __libcpp_tls_set(__libcpp_tls_key &__key, void *__p)
{
    return pthread_setspecific(__key._key, __p);
}

_LIBCPP_END_NAMESPACE_STD

#else

_LIBCPP_BEGIN_NAMESPACE_STD

class __libcpp_mutex_t {};
class __libcpp_condvar_t {};
class __libcpp_tls_t {};
class __libcpp_tls_key {};
class __libcpp_thread_id {};
class __libcpp_thread_t {};

_LIBCPP_END_NAMESPACE_STD

#endif // !_LIBCPP_HAS_THREAD_API_EXTERNAL || !__libcpp_has_include(<__external_threading>)

#endif // _LIBCPP_HAS_THREAD_API_PTHREAD

#endif // _LIBCPP_HAS_NO_THREADS

#endif // _LIBCPP_THREADING_SUPPORT
