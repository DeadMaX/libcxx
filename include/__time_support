// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_TIME_SUPPORT
#define _LIBCPP_TIME_SUPPORT

#include <__config>

#ifndef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
#pragma GCC system_header
#endif

#ifndef __libcpp_has_include
  #ifndef __has_include
    #define __libcpp_has_include(x) 0
  #else
    #define __libcpp_has_include(x) __has_include(x)
  #endif
#endif

#if defined(_LIBCPP_HAS_TIME_API_EXTERNAL) && \
    __libcpp_has_include(<__external_time>)
#include <__external_time>
#else

#include <__ctime_support>

_LIBCPP_BEGIN_NAMESPACE_STD

namespace chrono
{

#ifdef __APPLE__
//   mach_absolute_time() * MachInfo.numer / MachInfo.denom is the number of
//   nanoseconds since the computer booted up.  MachInfo.numer and MachInfo.denom
//   are run time constants supplied by the OS.  This clock has no relationship
//   to the Gregorian calendar.  It's main use is as a high resolution timer.

// MachInfo.numer / MachInfo.denom is often 1 on the latest equipment.  Specialize
//   for that case as an optimization.

#pragma GCC visibility push(hidden)

static
steady_clock::rep
steady_simplified()
{
    return static_cast<steady_clock::rep>(mach_absolute_time());
}

static
double
compute_steady_factor()
{
    mach_timebase_info_data_t MachInfo;
    mach_timebase_info(&MachInfo);
    return static_cast<double>(MachInfo.numer) / MachInfo.denom;
}

static
steady_clock::rep
steady_full()
{
    static const double factor = compute_steady_factor();
    return static_cast<steady_clock::rep>(mach_absolute_time() * factor);
}

typedef steady_clock::rep (*FP)();

static
FP
init_steady_clock()
{
    mach_timebase_info_data_t MachInfo;
    mach_timebase_info(&MachInfo);
    if (MachInfo.numer == MachInfo.denom)
        return &steady_simplified;
    return &steady_full;
}

#pragma GCC visibility pop
#endif // __APPLE__

template <class _Timepoint>
inline _LIBCPP_INLINE_VISIBILITY
_Timepoint __libcpp_get_current_time()
{
	using _Clock = typename _Timepoint::clock;
	using _Duration = typename _Timepoint::duration;

#if defined(CLOCK_REALTIME) && defined(CLOCK_MONOTONIC)
    struct timespec tp;
    if (0 != clock_gettime(_Clock::is_steady ? CLOCK_MONOTONIC : CLOCK_REALTIME, &tp))
        __throw_system_error(errno, "clock_gettime(CLOCK_xxx) failed");
    return _Timepoint(duration_cast<_Duration>(seconds(tp.tv_sec) + nanoseconds(tp.tv_nsec)));

#elif defined(__APPLE__)
# ifndef CLOCK_REALTIME
#  error CLOCK_REALTIME not defined
# endif
	if (_Clock::is_steady)
    {
		static FP fp = init_steady_clock();
		return _Timepoint(duration_cast<_Duration>(fp()));
	}
	else
	{
		struct timespec tp;
		if (0 != clock_gettime(CLOCK_REALTIME, &tp))
			__throw_system_error(errno, "clock_gettime(CLOCK_xxx) failed");
		return _Timepoint(duration_cast<_Duration>(seconds(tp.tv_sec) + nanoseconds(tp.tv_nsec)));
	}
#else  // !CLOCK_REALTIME
    timeval tv;
    gettimeofday(&tv, 0);
    return _Timepoint(duration_cast<_Duration>(seconds(tv.tv_sec) + microseconds(tv.tv_usec)));
#endif  // CLOCK_REALTIME
}

}


_LIBCPP_END_NAMESPACE_STD

#endif

#endif // _LIBCPP_STRING_SUPPORT
