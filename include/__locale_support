// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_LOCALE_SUPPORT
#define _LIBCPP_LOCALE_SUPPORT

#include <__config>

#ifndef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
#pragma GCC system_header
#endif

#ifndef __libcpp_has_include
  #ifndef __has_include
    #define __libcpp_has_include(x) 0
  #else
    #define __libcpp_has_include(x) __has_include(x)
  #endif
#endif

#if defined(_LIBCPP_HAS_LOCALE_API_EXTERNAL) && \
    __libcpp_has_include(<__external_locale>)
#include <__external_locale>
#else

#if defined(_LIBCPP_HAS_LOCALE_API_EXTERNAL)
#define _LIBCPP_LOCALE_ABI_VISIBILITY _LIBCPP_FUNC_VIS
#else
#define _LIBCPP_LOCALE_ABI_VISIBILITY inline _LIBCPP_INLINE_VISIBILITY
#endif

#include <__ctime_support>

_LIBCPP_BEGIN_NAMESPACE_STD

class __libcpp_locale_t;

_LIBCPP_LOCALE_ABI_VISIBILITY
long long __libcpp_get_signed_intergral(const char *__str, const char **__err, int __base,
										const __libcpp_locale_t &__locale, errc &__error_code);

template <typename _IOS>
_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_put_signed_intergral(char *__dst, size_t __dstlen, const __libcpp_locale_t &__locale, typename _IOS::fmtflags __flags, long long __v);

_LIBCPP_LOCALE_ABI_VISIBILITY
unsigned long long __libcpp_get_unsigned_intergral(const char *__str, const char **__err, int __base,
												   const __libcpp_locale_t &__locale, errc &__error_code);

template <typename _IOS>
_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_put_unsigned_intergral(char *__dst, size_t __dstlen, const __libcpp_locale_t &__locale, typename _IOS::fmtflags __flags, unsigned long long __v);

_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_put_pointer(char *__dst, size_t __dstlen, const __libcpp_locale_t &__locale, const void *__v);

_LIBCPP_LOCALE_ABI_VISIBILITY
float __libcpp_get_float(const char* __a, const char** __p2, const __libcpp_locale_t &__locale, errc &__error_code);

_LIBCPP_LOCALE_ABI_VISIBILITY
double __libcpp_get_double(const char* __a, const char** __p2, const __libcpp_locale_t &__locale, errc &__error_code);

template<typename _IOS>
_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_put_double(char *__dst, size_t __dstlen, const __libcpp_locale_t &__locale, typename _IOS::fmtflags __flags, int __precision, double __v);

_LIBCPP_LOCALE_ABI_VISIBILITY
long double __libcpp_get_long_double(const char* __a, const char** __p2, const __libcpp_locale_t &__locale,
									 errc &__error_code);
template<typename _IOS>
_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_put_long_double(char *__dst, size_t __dstlen, const __libcpp_locale_t &__locale, typename _IOS::fmtflags __flags, int __precision, long double __v);

_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_put_money(char *__dst, size_t __dstlen, const __libcpp_locale_t &__locale, long double __v);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_do_compare(const char* __a, const char* __b, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_do_transform(char* __dst, const char* __src, size_t __size, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_do_compare(const wchar_t* __a, const wchar_t* __b, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_do_transform(wchar_t* __dst, const wchar_t* __src, size_t __size, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
char __libcpp_do_toupper(char __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
char __libcpp_do_tolower(char __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
wchar_t __libcpp_do_toupper(wchar_t __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
wchar_t __libcpp_do_tolower(wchar_t __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_strftime(char *__out, size_t __len, const char *__format, const tm* __d,
                         const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
bool __libcpp_iswascii(wchar_t __c);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_iswspace_l(wchar_t __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_iswprint_l(wchar_t __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_iswcntrl_l(wchar_t __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_iswupper_l(wchar_t __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_iswlower_l(wchar_t __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_iswdigit_l(wchar_t __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_iswpunct_l(wchar_t __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_iswxdigit_l(wchar_t __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_iswblank_l(wchar_t __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_iswalpha_l(wchar_t __c, const __libcpp_locale_t &__locale);

template <typename _Mask, typename _Ctype>
_LIBCPP_LOCALE_ABI_VISIBILITY
bool __libcpp_is_wctype(wchar_t __c, _Mask __m, const __libcpp_locale_t &__locale);

template <typename _Mask>
_LIBCPP_LOCALE_ABI_VISIBILITY
_Mask __libcpp_get_wtype(wchar_t __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_mb_cur_max_l(const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
char_traits<wchar_t>::int_type __libcpp_btowc_l(char __c, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
char_traits<char>::int_type __libcpp_wctob_l(wchar_t, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_wcsnrtombs_l(char *__dst, const wchar_t *&__src, size_t __srclen, size_t __outlen, mbstate_t &__state,
							 const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_wcrtomb_l(char *__dst, wchar_t __c, mbstate_t &__state, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_mbsnrtowcs_l(wchar_t *__dst, const char *&__src, size_t __srclen, size_t __outlen, mbstate_t &__state,
							 const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_mbrtowc_l(wchar_t *__dst, const char *__src, size_t __srclen, mbstate_t &__state,
						  const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
int __libcpp_mbtowc_l(wchar_t*__dst, const char *__src, size_t __srclen, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_mbrlen_l(const char *__src, size_t __srclen, mbstate_t &__state, const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
size_t __libcpp_mbsrtowcs_l(wchar_t *__dst, const char *&__src, size_t __dstlen, mbstate_t &__state,
							const __libcpp_locale_t &__locale);

_LIBCPP_LOCALE_ABI_VISIBILITY
bool __libcpp_get_pointer(const char *__src, const __libcpp_locale_t &__locale, void *& __v);

_LIBCPP_END_NAMESPACE_STD

#ifndef _LIBCXX_DISABLE_C_LINKAGE

#include <locale.h>

#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)
# include <support/win32/locale_win32.h>
#elif defined(_AIX)
# include <support/ibm/xlocale.h>
#elif defined(__ANDROID__)
// Android gained the locale aware functions in L (API level 21)
# include <android/api-level.h>
# if __ANDROID_API__ <= 20
#  include <support/android/locale_bionic.h>
# endif
#elif defined(__sun__)
# include <xlocale.h>
# include <support/solaris/xlocale.h>
#elif defined(_NEWLIB_VERSION)
# include <support/newlib/xlocale.h>
#elif (defined(__GLIBC__) || defined(__APPLE__)      || defined(__FreeBSD__) \
    || defined(__EMSCRIPTEN__) || defined(__IBMCPP__))
# include <xlocale.h>
#elif defined(_LIBCPP_HAS_MUSL_LIBC)
# include <support/musl/xlocale.h>
#endif // __GLIBC__ || __APPLE__ || __FreeBSD__ || __sun__ || __EMSCRIPTEN__ || __IBMCPP__

#if !defined(__BIONIC__)
#include <langinfo.h>
#endif

#ifdef _LIBCPP_HAS_CATOPEN
#include <nl_types.h>
#endif

#ifdef __APPLE__
#include <Availability.h>
#endif


#if defined(__APPLE__) || defined(__FreeBSD__)
#  define _LIBCPP_GET_C_LOCALE 0
#elif defined(__CloudABI__) || defined(__NetBSD__)
#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE
#else
#  define _LIBCPP_GET_C_LOCALE __cloc()
   // Get the C locale object
   _LIBCPP_FUNC_VIS locale_t __cloc();
#define __cloc_defined
#endif

#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <vector>

_LIBCPP_BEGIN_NAMESPACE_STD

class __libcpp_locale_t
{
	bool __new_locale;
    locale_t __locale;
    lconv *__lconv;
    __libcpp_locale_t (locale_t __locale);
    wchar_t __w_decimal_point;
    wchar_t __w_thousands_sep;
    wchar_t __w_currency_symbol[100];
    wchar_t __w_money_positive_sign[100];
    wchar_t __w_money_negative_sign[100];
    void __init_lconv();
public:

    enum class __money_sign_position
    {
        __parentheses, // Parentheses surround the quantity and currency symbol.
        __before_all, // The sign string precedes the quantity and currency symbol.
        __after_all, // The sign string succeeds the quantity and currency symbol.
        __before_symbol, // The sign string immediately precedes the currency symbol.
        __after_symbol, // The sign string immediately succeeds the currency symbol.
    };
    
    enum class __money_space_separation
    {
        __nothing, // No space separates the currency symbol and value.
        __one_space, // Space between currency-and-sign or currency and value.
        __two_spaces, // Space between sign and currency or value.
    };
	__libcpp_locale_t ();
	__libcpp_locale_t (int __mask, const char *__name);
	~__libcpp_locale_t();
    locale_t __get_locale() const { return __locale; }
    char __get_decimal_point();
    wchar_t __getw_decimal_point();
    char __get_thousands_sep();
    wchar_t __getw_thousands_sep();
    const char *__get_grouping();
    const char *__get_money_grouping();
    const char *__get_money_symbol();
    const wchar_t *__getw_money_symbol();
    int __get_money_fract_digit();
    const char *__get_money_positive_sign();
    const wchar_t *__getw_money_positive_sign();
    const char *__get_money_negative_sign();
    const wchar_t *__getw_money_negative_sign();
    bool __is_money_positive_sign_precedes();
    bool __is_money_negative_sign_precedes();
    __money_space_separation __get_money_positive_separation();
    __money_space_separation __get_money_negative_separation();
    __money_sign_position __get_money_positive_sign_position();
    __money_sign_position __get_money_negative_sign_position();
};

#ifndef _LIBCPP_LOCALE__L_EXTENSIONS
typedef _VSTD::remove_pointer<locale_t>::type __use_locale_struct;
typedef _VSTD::unique_ptr<__use_locale_struct, decltype(&uselocale)> __locale_raii;
#endif

long long __libcpp_get_signed_intergral(const char *__str, const char **__err, int __base,
										const __libcpp_locale_t &__locale, errc &__error_code)
{
    typename remove_reference<decltype(errno)>::type __save_errno = errno;
    long long value = strtoll_l(__str, const_cast<char **>(__err), __base, __locale.__get_locale());
    typename remove_reference<decltype(errno)>::type __curr_errno = errno;
    if (__curr_errno == 0)
        errno = __save_errno;
    else if (__curr_errno == ERANGE)
        __error_code = errc::result_out_of_range;

    return value;
}

template <typename _IOS>
inline _LIBCPP_INLINE_VISIBILITY
void __libcpp_format_int(char* __fmtp, const char* __len, bool __signd,
                        typename _IOS::fmtflags __flags)
{
    if (__flags & _IOS::showpos)
        *__fmtp++ = '+';
    if (__flags & _IOS::showbase)
        *__fmtp++ = '#';
    while(*__len)
        *__fmtp++ = *__len++;
    if ((__flags & _IOS::basefield) == _IOS::oct)
        *__fmtp = 'o';
    else if ((__flags & _IOS::basefield) == _IOS::hex)
    {
        if (__flags & _IOS::uppercase)
            *__fmtp = 'X';
        else
            *__fmtp = 'x';
    }
    else if (__signd)
        *__fmtp = 'd';
    else
        *__fmtp = 'u';
}

template <typename _IOS>
inline _LIBCPP_INLINE_VISIBILITY
bool __libcpp_format_float(char* __fmtp, const char* __len,
                               typename _IOS::fmtflags __flags)
{
    bool specify_precision = true;
    if (__flags & _IOS::showpos)
        *__fmtp++ = '+';
    if (__flags & _IOS::showpoint)
        *__fmtp++ = '#';
    typename _IOS::fmtflags floatfield = __flags & _IOS::floatfield;
    bool uppercase = (__flags & _IOS::uppercase) != 0;
    if (floatfield == (_IOS::fixed | _IOS::scientific))
        specify_precision = false;
    else
    {
        *__fmtp++ = '.';
        *__fmtp++ = '*';
    }
    while(*__len)
        *__fmtp++ = *__len++;
    if (floatfield == _IOS::fixed)
    {
        if (uppercase)
            *__fmtp = 'F';
        else
            *__fmtp = 'f';
    }
    else if (floatfield == _IOS::scientific)
    {
        if (uppercase)
            *__fmtp = 'E';
        else
            *__fmtp = 'e';
    }
    else if (floatfield == (_IOS::fixed | _IOS::scientific))
    {
        if (uppercase)
            *__fmtp = 'A';
        else
            *__fmtp = 'a';
    }
    else
    {
        if (uppercase)
            *__fmtp = 'G';
        else
            *__fmtp = 'g';
    }
    return specify_precision;
}

template <typename _IOS>
size_t __libcpp_put_signed_intergral(char *__dst, size_t __dstlen, const __libcpp_locale_t &__locale, typename _IOS::fmtflags __flags, long long __v)
{
    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    __libcpp_format_int<_IOS>(__fmt+1, __len, true, __flags);
    int __outlen = snprintf(__dst, __dstlen, __fmt, __v);
    if (__outlen < 0 || size_t(__outlen) >= __dstlen)
        __throw_runtime_error("Unable to format integer");
    return __outlen;
}

unsigned long long __libcpp_get_unsigned_intergral(const char *__str, const char **__err, int __base,
												   const __libcpp_locale_t &__locale, errc &__error_code)
{
    typename remove_reference<decltype(errno)>::type __save_errno = errno;
    unsigned long long value = strtoull_l(__str, const_cast<char **>(__err), __base, __locale.__get_locale());
    typename remove_reference<decltype(errno)>::type __curr_errno = errno;
    if (__curr_errno == 0)
        errno = __save_errno;
    else if (__curr_errno == ERANGE)
        __error_code = errc::result_out_of_range;

    return value;
}

template <typename _IOS>
size_t __libcpp_put_unsigned_intergral(char *__dst, size_t __dstlen, const __libcpp_locale_t &__locale, typename _IOS::fmtflags __flags, unsigned long long __v)
{
    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    __libcpp_format_int<_IOS>(__fmt+1, __len, false, __flags);
    int __outlen = snprintf(__dst, __dstlen, __fmt, __v);
    if (__outlen < 0 || size_t(__outlen) >= __dstlen)
        __throw_runtime_error("Unable to format integer");
    return __outlen;
}

size_t __libcpp_put_pointer(char *__dst, size_t __dstlen, const __libcpp_locale_t &__locale, const void *__v)
{
    const char *__fmt = "%p";
    int __outlen = snprintf(__dst, __dstlen, __fmt, __v);
    if (__outlen < 0 || size_t(__outlen) >= __dstlen)
        __throw_runtime_error("Unable to format pointer");
    return __outlen;
}

float __libcpp_get_float(const char* __a, const char** __p2, const __libcpp_locale_t &__locale, errc &__error_code) {
    typename remove_reference<decltype(errno)>::type __save_errno = errno;
    float value = strtof_l(__a, const_cast<char **>(__p2), __locale.__get_locale());
    typename remove_reference<decltype(errno)>::type __curr_errno = errno;
    if (__curr_errno == 0)
        errno = __save_errno;
    else if (__curr_errno == ERANGE)
        __error_code = errc::result_out_of_range;

    return value;
}

template <typename _IOS>
size_t __libcpp_put_double(char *__dst, size_t __dstlen, const __libcpp_locale_t &__locale, typename _IOS::fmtflags __flags, int __precision, double __v)
{
    char __fmt[8] = {'%', 0};
    const char* __len = "";
    bool __specify_precision = __libcpp_format_float<_IOS>(__fmt+1, __len, __flags);
    int __outlen;
    if (__specify_precision)
        __outlen = snprintf(__dst, __dstlen, __fmt, __precision, __v);
    else
        __outlen = snprintf(__dst, __dstlen, __fmt, __v);
    if (__outlen < 0)
        __throw_runtime_error("Unable to format double");
    return __outlen;
}


double __libcpp_get_double(const char* __a, const char** __p2, const __libcpp_locale_t &__locale, errc &__error_code) {
    typename remove_reference<decltype(errno)>::type __save_errno = errno;
    double value = strtod_l(__a, const_cast<char **>(__p2), __locale.__get_locale());
    typename remove_reference<decltype(errno)>::type __curr_errno = errno;
    if (__curr_errno == 0)
        errno = __save_errno;
    else if (__curr_errno == ERANGE)
        __error_code = errc::result_out_of_range;

    return value;
}

template <typename _IOS>
size_t __libcpp_put_long_double(char *__dst, size_t __dstlen, const __libcpp_locale_t &__locale, typename _IOS::fmtflags __flags, int __precision, long double __v)
{
    char __fmt[8] = {'%', 0};
    const char* __len = "L";
    bool __specify_precision = __libcpp_format_float<_IOS>(__fmt+1, __len, __flags);
    int __outlen;
    if (__specify_precision)
        __outlen = snprintf(__dst, __dstlen, __fmt, __precision, __v);
    else
        __outlen = snprintf(__dst, __dstlen, __fmt, __v);
    if (__outlen < 0)
        __throw_runtime_error("Unable to format long double");
    return __outlen;
}

long double __libcpp_get_long_double(const char* __a, const char** __p2, const __libcpp_locale_t &__locale,
									 errc &__error_code) {
    typename remove_reference<decltype(errno)>::type __save_errno = errno;
    long double value = strtold_l(__a, const_cast<char **>(__p2), __locale.__get_locale());
    typename remove_reference<decltype(errno)>::type __curr_errno = errno;
    if (__curr_errno == 0)
        errno = __save_errno;
    else if (__curr_errno == ERANGE)
        __error_code = errc::result_out_of_range;

    return value;
}

size_t __libcpp_put_money(char *__dst, size_t __dstlen, const __libcpp_locale_t &__locale, long double __v)
{
    const char *__fmt = "%.0Lf";
    int __outlen;
    __outlen = snprintf(__dst, __dstlen, __fmt, __v);
    if (__outlen < 0)
        __throw_runtime_error("Unable to format money");
    return __outlen;
}

int __libcpp_do_compare(const char* __a, const char* __b, const __libcpp_locale_t &__locale)
{
	return strcoll_l(__a, __b, __locale.__get_locale());
}

size_t __libcpp_do_transform(char* __dst, const char* __src, size_t __size, const __libcpp_locale_t &__locale)
{
	return strxfrm_l(__dst, __src, __size, __locale.__get_locale());
}

int __libcpp_do_compare(const wchar_t* __a, const wchar_t* __b, const __libcpp_locale_t &__locale)
{
	return wcscoll_l(__a, __b, __locale.__get_locale());
}

size_t __libcpp_do_transform(wchar_t* __dst, const wchar_t* __src, size_t __size, const __libcpp_locale_t &__locale)
{
	return wcsxfrm_l(__dst, __src, __size, __locale.__get_locale());
}

char __libcpp_do_toupper(char __c, const __libcpp_locale_t &__locale)
{
	return static_cast<char>(toupper_l(static_cast<unsigned char>(__c), __locale.__get_locale()));
}

char __libcpp_do_tolower(char __c, const __libcpp_locale_t &__locale)
{
	return static_cast<char>(tolower_l(static_cast<unsigned char>(__c), __locale.__get_locale()));
}

wchar_t __libcpp_do_toupper(wchar_t __c, const __libcpp_locale_t &__locale)
{
	return towupper_l(__c, __locale.__get_locale());
}

wchar_t __libcpp_do_tolower(wchar_t __c, const __libcpp_locale_t &__locale)
{
	return towlower_l(__c, __locale.__get_locale());
}

bool __libcpp_iswascii(wchar_t __c)
{
#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
    return iswascii(__c);
#else
    return isascii(__c);
#endif
    
}

int __libcpp_iswspace_l(wchar_t __c, const __libcpp_locale_t &__locale)
{
    return iswspace_l(__c, __locale.__get_locale());
}

int __libcpp_iswprint_l(wchar_t __c, const __libcpp_locale_t &__locale)
{
    return iswprint_l(__c, __locale.__get_locale());
}

int __libcpp_iswcntrl_l(wchar_t __c, const __libcpp_locale_t &__locale)
{
    return iswcntrl_l(__c, __locale.__get_locale());
}

int __libcpp_iswupper_l(wchar_t __c, const __libcpp_locale_t &__locale)
{
    return iswupper_l(__c, __locale.__get_locale());
}

int __libcpp_iswlower_l(wchar_t __c, const __libcpp_locale_t &__locale)
{
    return iswlower_l(__c, __locale.__get_locale());
}

int __libcpp_iswdigit_l(wchar_t __c, const __libcpp_locale_t &__locale)
{
    return iswdigit_l(__c, __locale.__get_locale());
}

int __libcpp_iswpunct_l(wchar_t __c, const __libcpp_locale_t &__locale)
{
    return iswpunct_l(__c, __locale.__get_locale());
}

int __libcpp_iswxdigit_l(wchar_t __c, const __libcpp_locale_t &__locale)
{
    return iswxdigit_l(__c, __locale.__get_locale());
}

int __libcpp_iswblank_l(wchar_t __c, const __libcpp_locale_t &__locale)
{
    return iswblank_l(__c, __locale.__get_locale());
}

int __libcpp_iswalpha_l(wchar_t __c, const __libcpp_locale_t &__locale)
{
    return iswalpha_l(__c, __locale.__get_locale());
}

template <typename _Mask, typename _Ctype>
bool __libcpp_is_wctype(wchar_t __c, _Mask __m, const __libcpp_locale_t &__locale)
{
#ifdef _LIBCPP_WCTYPE_IS_MASK
    return static_cast<bool>(__libcpp_iswctype_l(__c, __m, __locale.__get_locale()));
#else
    bool result = false;
    char_traits<wchar_t>::int_type ch = char_traits<wchar_t>::to_int_type(__c);
    if ((__m & _Ctype::space) == _Ctype::space) result |= (__libcpp_iswspace_l(ch, __locale) != 0);
    if ((__m & _Ctype::print) == _Ctype::print) result |= (__libcpp_iswprint_l(ch, __locale) != 0);
    if ((__m & _Ctype::cntrl) == _Ctype::cntrl) result |= (__libcpp_iswcntrl_l(ch, __locale) != 0);
    if ((__m & _Ctype::upper) == _Ctype::upper) result |= (__libcpp_iswupper_l(ch, __locale) != 0);
    if ((__m & _Ctype::lower) == _Ctype::lower) result |= (__libcpp_iswlower_l(ch, __locale) != 0);
    if ((__m & _Ctype::alpha) == _Ctype::alpha) result |= (__libcpp_iswalpha_l(ch, __locale) != 0);
    if ((__m & _Ctype::digit) == _Ctype::digit) result |= (__libcpp_iswdigit_l(ch, __locale) != 0);
    if ((__m & _Ctype::punct) == _Ctype::punct) result |= (__libcpp_iswpunct_l(ch, __locale) != 0);
    if ((__m & _Ctype::xdigit) == _Ctype::xdigit) result |= (__libcpp_iswxdigit_l(ch, __locale) != 0);
    if ((__m & _Ctype::blank) == _Ctype::blank) result |= (__libcpp_iswblank_l(ch, __locale) != 0);
    return result;
#endif
}

size_t __libcpp_strftime(char *__out, size_t __len, const char *__format, const tm* __d,
						 const __libcpp_locale_t &__locale)
{
	return strftime_l(__out, __len, __format, __d, __locale.__get_locale());
}

bool __libcpp_get_pointer(const char *__src, const __libcpp_locale_t &__locale, void *& __v)
{
#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
    return sscanf_l(__src, __locale.__get_locale(), "%p", &__v) == 1;
#else
    __locale_raii __current( uselocale(__locale.__get_locale()), uselocale );
    return sscanf(__src, "%p", &__v) == 1;
#endif
}

_LIBCPP_END_NAMESPACE_STD

#else // _LIBCXX_DISABLE_C_LINKAGE

# define LC_COLLATE_MASK    (1<<0)
# define LC_CTYPE_MASK      (1<<1)
# define LC_MONETARY_MASK   (1<<2)
# define LC_NUMERIC_MASK    (1<<3)
# define LC_TIME_MASK       (1<<4)
# define LC_MESSAGES_MASK   (1<<5)

_LIBCPP_BEGIN_NAMESPACE_STD

class __libcpp_locale_t {};

_LIBCPP_END_NAMESPACE_STD

#endif // _LIBCXX_DISABLE_C_LINKAGE

#endif

#endif // _LIBCPP_LOCALE_SUPPORT
